<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.23">
<title>XrSessionState(3)</title>
<link rel="stylesheet" href="css/khronos.css">
<link rel="stylesheet" href="css/rouge-github.css">
<style>
/* Khronos overrides for Rouge 'github' theme for accessibility */
/* Basically everything is overridden, but it is unclear how to add a new Rouge theme */
/* Codelike overrides */
pre.rouge .cm, pre.rouge .cp, pre.rouge .c1, pre.rouge .cs,
pre.rouge .c, pre.rouge .ch, pre.rouge .cd, pre.rouge .cpf,
pre.rouge .gh, pre.rouge .bp {
  color: #5f5f5f;
}
/* Numberlike overrides */
pre.rouge .mf, pre.rouge .mh, pre.rouge .il, pre.rouge .mi,
pre.rouge .mo, pre.rouge .m, pre.rouge .mb, pre.rouge .mx {
  color: #007979;
}
/* Namelike overrides */
pre.rouge .ne, pre.rouge .nf, pre.rouge .fm, pre.rouge .nl {
  color: #5f0000;
}
/* Other things ANDI warns about - unsure of their purposes */
pre.rouge .go, pre.rouge .gu {
  color: #727272;
}
pre.rouge .s {
  color: #d70b3e;
}
pre.rouge .sr {
  color: #008512;
}
pre.rouge .na, pre.rouge .nb {
  color: #007979;
}
pre.rouge .no, pre.rouge .vc, pre.rouge .vg, pre.rouge .vi,
pre.rouge .nv, pre.rouge .vm {
  color: #007f7f;
}
pre.rouge .w {
  color: #727272;
}
</style>
</head>
<body class="manpage">
<div id="header">
<h1>XrSessionState(3) Manual Page</h1>
<h2 id="_name">Name</h2>
<div class="sectionbody">
<p>XrSessionState - Session lifecycle state</p>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_c_specification">C Specification</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="XrSessionState.html">XrSessionState</a> enumerates the possible session lifecycle states:</p>
</div>
<div id="XrSessionState" class="paragraph">
<p></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="c++"><span class="k">typedef</span> <span class="k">enum</span> <span class="n">XrSessionState</span> <span class="p">{</span>
    <span class="n">XR_SESSION_STATE_UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_IDLE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_READY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_SYNCHRONIZED</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_VISIBLE</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_FOCUSED</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_STOPPING</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_LOSS_PENDING</span> <span class="o">=</span> <span class="mi">7</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_EXITING</span> <span class="o">=</span> <span class="mi">8</span><span class="p">,</span>
    <span class="n">XR_SESSION_STATE_MAX_ENUM</span> <span class="o">=</span> <span class="mh">0x7FFFFFFF</span>
<span class="p">}</span> <span class="n">XrSessionState</span><span class="p">;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_description">Description</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="title">Enumerant Descriptions</div>
<div class="ulist">
<ul>
<li>
<p><code>XR_SESSION_STATE_UNKNOWN</code>.
An unknown state.
The runtime <strong class="purple">must</strong> not return this value in an
<a href="XrEventDataSessionStateChanged.html">XrEventDataSessionStateChanged</a> event.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_IDLE</code>.
The initial state after calling <a href="xrCreateSession.html">xrCreateSession</a> or returned to after
calling <a href="xrEndSession.html">xrEndSession</a>.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_READY</code>.
The application is ready to call <a href="xrBeginSession.html">xrBeginSession</a> and
<a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">sync its frame loop with the runtime.</a></p>
</li>
<li>
<p><code>XR_SESSION_STATE_SYNCHRONIZED</code>.
The application has synced its frame loop with the runtime but is not
visible to the user.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_VISIBLE</code>.
The application has <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">synced its frame loop with
the runtime</a> and is visible to the user but cannot receive XR input.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_FOCUSED</code>.
The application has <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">synced its frame loop with
the runtime</a>, is visible to the user and can receive XR input.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_STOPPING</code>.
The application should exit its frame loop and call <a href="xrEndSession.html">xrEndSession</a>.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_LOSS_PENDING</code>.
The session is in the process of being lost.
The application should destroy the current session and can optionally
recreate it.</p>
</li>
<li>
<p><code>XR_SESSION_STATE_EXITING</code>.
The application should end its XR experience and not automatically restart
it.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>The <code>XR_SESSION_STATE_UNKNOWN</code> state <strong class="purple">must</strong> not be returned by the
runtime, and is only defined to avoid <code>0</code> being a valid state.</p>
</div>
<div id="XR_SESSION_STATE_IDLE" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_IDLE</code> state indicates that the runtime
considers the session is idle.
Applications in this state <strong class="purple">should</strong> minimize resource consumption but
continue to call <a href="xrPollEvent.html">xrPollEvent</a> at some reasonable cadence.</p>
</div>
<div id="XR_SESSION_STATE_READY" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_READY</code> state indicates that the runtime
desires the application to prepare rendering resources, begin its session
and synchronize its frame loop with the runtime.</p>
</div>
<div id="session-sync-frame-loop" class="paragraph">
<p>The application does this by successfully calling <a href="xrBeginSession.html">xrBeginSession</a> and
then running its frame loop by calling <a href="xrWaitFrame.html">xrWaitFrame</a>, <a href="xrBeginFrame.html">xrBeginFrame</a>
and <a href="xrEndFrame.html">xrEndFrame</a> in a loop.
If the runtime wishes to return the session to the
<code>XR_SESSION_STATE_IDLE</code> state, it <strong class="purple">must</strong> wait until the application calls
<a href="xrBeginSession.html">xrBeginSession</a>.
After returning from the <a href="xrBeginSession.html">xrBeginSession</a> call, the runtime may then
immediately transition forward through the
<code>XR_SESSION_STATE_SYNCHRONIZED</code> state to the
<code>XR_SESSION_STATE_STOPPING</code> state, to request that the application end
this session.
If the system supports a user engagement sensor and runtime is in
<code>XR_SESSION_STATE_IDLE</code> state, the runtime <strong class="purple">may</strong> wait until the user
starts engaging with the device before transitioning to the
<code>XR_SESSION_STATE_READY</code> state.</p>
</div>
<div id="XR_SESSION_STATE_SYNCHRONIZED" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_SYNCHRONIZED</code> state indicates that the
application has <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">synchronized its frame loop with
the runtime</a>, but its frames are not visible to the user.
The application <strong class="purple">should</strong> continue running its frame loop by calling
<a href="xrWaitFrame.html">xrWaitFrame</a>, <a href="xrBeginFrame.html">xrBeginFrame</a> and <a href="xrEndFrame.html">xrEndFrame</a>, although it
should avoid heavy GPU work so that other visible applications can take CPU
and GPU precedence.
The application can save resources here by skipping rendering and not
submitting any composition layers until <a href="xrWaitFrame.html">xrWaitFrame</a> returns an
<a href="XrFrameState.html">XrFrameState</a> with <code>shouldRender</code> set to true.
A runtime <strong class="purple">may</strong> use this frame synchronization to facilitate seamless
switching from a previous XR application to this application on a frame
boundary.</p>
</div>
<div id="XR_SESSION_STATE_VISIBLE" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_VISIBLE</code> state indicates that the
application has <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">synchronized its frame loop with
the runtime</a>, and the session&#8217;s frames will be visible to the user, but the
session is not eligible to receive XR input.
An application may be visible but not have focus, for example when the
runtime is composing a modal pop-up on top of the application&#8217;s rendered
frames.
The application <strong class="purple">should</strong> continue running its frame loop, rendering and
submitting its composition layers, although it may wish to pause its
experience, as users cannot interact with the application at this time.
It is important for applications to continue rendering when visible, even
when they do not have focus, so the user continues to see something
reasonable underneath modal pop-ups.
Runtimes <strong class="purple">should</strong> make input actions inactive while the application is
unfocused, and applications should react to an inactive input action by
skipping rendering of that action&#8217;s input avatar (depictions of hands or
other tracked objects controlled by the user).</p>
</div>
<div id="XR_SESSION_STATE_FOCUSED" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_FOCUSED</code> state indicates that the
application has <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#session-sync-frame-loop" target="_blank" rel="noopener">synchronized its frame loop with
the runtime</a>, the session&#8217;s frames will be visible to the user, and the
session is eligible to receive XR input.
The runtime <strong class="purple">should</strong> only give one session XR input focus at any given time.
The application <strong class="purple">should</strong> be running its frame loop, rendering and submitting
composition layers, including input avatars (depictions of hands or other
tracked objects controlled by the user) for any input actions that are
active.
The runtime <strong class="purple">should</strong> avoid rendering its own input avatars when an
application is focused, unless input from a given source is being captured
by the runtime at the moment.</p>
</div>
<div id="XR_SESSION_STATE_STOPPING" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_STOPPING</code> state indicates that the
runtime has determined that the application should halt its rendering loop.
Applications <strong class="purple">should</strong> exit their rendering loop and call <a href="xrEndSession.html">xrEndSession</a>
when in this state.
A possible reason for this would be to minimize contention between multiple
applications.
If the system supports a user engagement sensor and the session is running,
the runtime <strong class="purple">may</strong> transition to the <code>XR_SESSION_STATE_STOPPING</code> state
when the user stops engaging with the device.</p>
</div>
<div id="XR_SESSION_STATE_EXITING" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_EXITING</code> state indicates the runtime
wishes the application to terminate its XR experience, typically due to a
user request via a runtime user interface.
Applications <strong class="purple">should</strong> gracefully end their process when in this state if they
do not have a non-XR user experience.</p>
</div>
<div id="XR_SESSION_STATE_LOSS_PENDING" class="paragraph">
<p>Receiving the <code>XR_SESSION_STATE_LOSS_PENDING</code> state indicates the
runtime is no longer able to operate with the current session, for example
due to the loss of a display hardware connection.
An application <strong class="purple">should</strong> call <a href="xrDestroySession.html">xrDestroySession</a> and <strong class="purple">may</strong> end its process
or decide to poll <a href="xrGetSystem.html">xrGetSystem</a> at some reasonable cadence to get a new
<a href="XrSystemId.html">XrSystemId</a>, and re-initialize all graphics resources related to the
new system, and then create a new session using <a href="xrCreateSession.html">xrCreateSession</a>.
After the event is queued, subsequent calls to functions that accept
<a href="XrSession.html">XrSession</a> parameters <strong class="purple">must</strong> no longer return any success code other
than <code>XR_SESSION_LOSS_PENDING</code> for the given <a href="XrSession.html">XrSession</a> handle.
The <code>XR_SESSION_LOSS_PENDING</code> success result is returned for an
unspecified grace period of time, and the functions that return it simulate
success in their behavior.
If the runtime has no reasonable way to successfully complete a given
function (e.g. <a href="xrCreateSwapchain.html">xrCreateSwapchain</a>) when a lost session is pending, or
if the runtime is not able to provide the application a grace period, the
runtime <strong class="purple">may</strong> return <code>XR_ERROR_SESSION_LOST</code>.
Thereafter, functions which accept <a href="XrSession.html">XrSession</a> parameters for the lost
session <strong class="purple">may</strong> return <code>XR_ERROR_SESSION_LOST</code> to indicate that the
function failed and the given session was lost.
The <a href="XrSession.html">XrSession</a> handle and child handles are henceforth unusable and
<strong class="purple">should</strong> be destroyed by the application in order to immediately free up
resources associated with those handles.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_see_also">See Also</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="XrEventDataSessionStateChanged.html">XrEventDataSessionStateChanged</a>, <a href="xrPollEvent.html">xrPollEvent</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_document_notes">Document Notes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>For more information, see the <a href="https://registry.khronos.org/OpenXR/specs/1.1/html/xrspec.html#XrSessionState" target="_blank" rel="noopener">OpenXR Specification</a></p>
</div>
<div class="paragraph">
<p>This page is extracted from the OpenXR Specification.
Fixes and changes should be made to the Specification, not directly.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright">Copyright</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright 2014-2025 The Khronos Group Inc.</p>
</div>
<div class="paragraph">
<p>This work is licensed under a
<a href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0
International License</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 1.1.49<br>
</div>
</div>
</body>
</html>